use it-academy
db.Restaurants.find()
db.Restaurants.find({}, {"restaurant_id": 1, "name": 1, "borough": 1, "cuisine": 1})
db.Restaurants.find({}, {"_id": 0, "restaurant_id": 1, "name": 1, "borough": 1, "cuisine": 1})
db.Restaurants.find({}, {"_id": 0, "restaurant_id": 1, "name": 1, "borough": 1, "address.zipcode": 1})
db.Restaurants.find({"borough": "Bronx"})
db.Restaurants.find({"borough": "Bronx"}).limit(5)
db.Restaurants.find({"borough": "Bronx"}).skip(5).limit(5)
db.Restaurants.find({"grades.score": {$gt: 90}})
db.Restaurants.find({grades: {$elemMatch: {score: {$gt: 80, $lt: 100}}}})
db.Restaurants.find({"address.coord.0": {$lt: -95.754168}})
db.Restaurants.find({$and: [{cuisine: {$not: /American/i}}, {"grades.score": {$gt: 70}}, {"address.coord.1": {$lt: -65.754168}}]}) //El mínim de latitut a la bd és: -28.... Es pot trobar així: db.Restaurants.aggregate([{$group: {_id: null, minLatitude: {$min: {$arrayElemAt: ["$address.coord", 1]}}}}])
db.Restaurants.find({cuisine: {$not: /American/i}, "grades.score": {$gt: 70}, "address.coord.0": {$lt: -65.754168}})
db.Restaurants.find({cuisine: {$not: /American/i}, "grades.grade": 'A', borough: {$not: /Brooklyn/}}).sort({"cuisine": -1})
db.Restaurants.find({name: {$regex: /^Wil/}}, {_id: 0, "restaurant_id": 1, "name": 1, "borough": 1, "cuisine": 1})
db.Restaurants.find({name: {$regex: /ces$/}}, {_id: 0, "restaurant_id": 1, "name": 1, "borough": 1, "cuisine": 1})
db.Restaurants.find({name: {$regex: /Reg/}}, {_id: 0, "restaurant_id": 1, "name": 1, "borough": 1, "cuisine": 1})
db.Restaurants.find({borough: 'Bronx', cuisine: {$in: [/American/, /Chinese/]}})
db.Restaurants.find({borough: {$in: ["Staten Island", "Queens", "Bronx", "Brooklyn"]}}, {_id: 0, restaurant_id: 1, name: 1, borough: 1, cuisine: 1})
db.Restaurants.find({borough: {$not: {$in: ["Staten Island", "Queens", "Bronx", "Brooklyn"]}}}, {_id: 0, restaurant_id: 1, name: 1, borough: 1, cuisine: 1})
db.Restaurants.find({"grades.score": {$lt: 10}}, {_id: 0, restaurant_id: 1, name: 1, borough: 1, cuisine: 1})
db.Restaurants.find({$and: [{cuisine: /seafood/i}, {cuisine: {$not: {$in: ["American", "Chinese"]}}}, {name: {$not: /^Wil/}}]}, {_id:0, restaurant_id: 1, name: 1, borough: 1, cuisine: 1}) //Cerca incongruent: a la base de dades no hi ha cap restaurant de Seafood amb nom que comença per Wil. Si cerquem cuisine = seafood, no pot ser ni American, ni Chinese, ni d'altres...
db.Restaurants.find({"grades.grade": 'A', "grades.score": 11, "grades.date": ISODate("2014-08-11T00:00:00Z")}, {_id: 0, restaurant_id: 1, name: 1, grades: 1})
db.Restaurants.find({"grades.1.grade": 'A', "grades.1.score": 9, "grades.1.date": ISODate("2014-08-11T00:00:00Z")}, {_id:0, restaurant_id: 1, name:1, grades: 1})
db.Restaurants.find({"address.coord.1": {$gt: 42, $lt: 52}}, {_id:0, restaurant_id: 1, name: 1, "address.street": 1, "address.coord": 1})
db.Restaurants.find().sort({"name": 1})
db.Restaurants.find().sort({"name": -1})
db.Restaurants.find().sort({"cuisine": 1, "borough": -1})
db.Restaurants.find({"address.street": {$not: {$in: [{"address.street": ""}, {"address.street": {$exists: false}}]}}})
db.Restaurants.find({"address.coord": {$type: 1}})
db.Restaurants.find({grades: {$elemMatch: {score: {$mod: [7, 0]}}}}, {_id:0, restaurant_id: 1, name: 1, grades: 1})
db.Restaurants.aggregate([{$match: {name: /mon/}}, {$project: {_id: 0, name: 1, borough: 1, cuisine: 1, latitud: {$arrayElemAt: ["$address.coord", 1]}, longitud: {$arrayElemAt: ["$address.coord", 0]}}}])
db.Restaurants.aggregate([{$match: {name: /^Mad/}}, {$project: {_id: 0, name: 1, borough: 1, longitud: {$arrayElemAt: ["$address.coord", 0]}, latitud: {$arrayElemAt: ["$address.coord", 1]}}}])